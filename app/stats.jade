.span12
	ul.nav.nav-tabs
		li.active: a(href="#output-content", data-toggle="tab") Output
		li: a(href="#assets-content", data-toggle="tab") Assets
		li: a(href="#chunks-content", data-toggle="tab") Chunks
		li: a(href="#modules-content", data-toggle="tab") Modules
		li.hide: a#chunk-view(href="#chunk-view-content", data-toggle="tab") Chunk X
		li.hide: a#module-view(href="#module-view-content", data-toggle="tab") Module X
		li: a(href="#hints-content", data-toggle="tab") Hints
	.tab-content
		.tab-pane.active#output-content
			pre: code= statsOutput
		.tab-pane#assets-content
			center: svg.assets-graph
			p The size of each bubble represents the filesize.
			assetTemplate = require("./asset.jade");
			table.table.table-bordered
				thead
					tr
						th Asset
						th Size
						th Chunks
						th Names
				tbody
					for asset in stats.assets
						!= assetTemplate({asset: asset})
		.tab-pane#chunks-content
			center: svg.chunks-graph
			p This graph displays all chunks. A connection between two chunks means that one chunk may async load the other chunk.
			chunkTemplate = require("./chunk.jade");
			table.table.table-bordered
				thead
					tr
						th Chunk
						th Size
						th Modules
						th Names
						th Files
				tbody
					for chunk in stats.chunks
						!= chunkTemplate({chunk: chunk})
		.tab-pane#modules-content
			center: svg.modules-graph
			p This graph displays all modules separated by chunk. The size of each bubble represents the module size.
			moduleTemplate = require("./module.jade");
			table.table.table-bordered
				thead
					tr
						th Module
						th Name
						th Size
						th Attributes
						th Saving
				tbody
					for module in stats.modules
						!= moduleTemplate({module: module})
		.tab-pane#chunk-view-content
		.tab-pane#module-view-content
		.tab-pane#hints-content
			p Keep in mind that this are only <strong>hints</strong> and the choice is still up to the developer. Not every hint is a good change.
			if multiChunks.length > 0
				h2 Module in multiple chunks
				p Check if it is a good idea to move modules into a common parent. You may want to use <code>require.include</code> or insert the parents <code>require.ensure</code> array.
				table.table.table-bordered
					thead
						tr
							th Module
							th Name
							th Count
							th Chunks
							th Saving
					tbody
						for item in multiChunks
							tr
								td: a.open-module(href="#", data-module=item.module.id)= item.module.id
								splittedModule = item.module.name.split("!")
								td
									for item, idx in splittedModule
										div: code= item + (idx != splittedModule.length-1 ? "!" : "")
								td= item.count
								td
									for chunk, idx in item.module.chunks
										if idx > 0
											= ", "
										a.open-chunk(href="#", data-chunk=chunk)= chunk
								td= item.saving > 2048 ? Math.round(item.saving / 1024) + "K" : item.saving + "B";
			if multiRefs.length > 0
				h2 Multiple references to the same module
				p Refactor this:
				pre: code.
					var a = require("xyz").a;
					var b = require("xyz").b;
					var c = require("xyz").c;
				p To this:
				pre: code.
					var xyz = require("xyz");
					var a = xyz.a;
					var a = xyz.b;
					var c = xyz.c;
				table.table.table-bordered
					thead
						tr
							th Module
							th Name
							th Count
							th Referenced Module
							th Referenced Name
							th Saving
					tbody
						for item in multiRefs
							tr
								td: a.open-module(href="#", data-module=item.module.id)= item.module.id
								splittedModule = item.module.name.split("!")
								td
									for item, idx in splittedModule
										div: code= item + (idx != splittedModule.length-1 ? "!" : "")
								td= item.count
								td: a.open-module(href="#", data-module=item.otherModule.id)= item.otherModule.id
								splittedModule = item.otherModule.name.split("!")
								td
									for item, idx in splittedModule
										div: code= item + (idx != splittedModule.length-1 ? "!" : "")
								td= item.saving + "B+"
	